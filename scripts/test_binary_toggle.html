<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test Bench: Polished Leak (Final)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, sans-serif;
            overflow: hidden;
        }

        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* Unlabelled Controls */
        .controls-panel {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 100;
            opacity: 0.3;
            /* Subtle */
            transition: opacity 0.3s;
        }

        .controls-panel:hover {
            opacity: 1.0;
        }

        input[type=range] {
            writing-mode: bt-lr;
            /* IE/Edge */
            -webkit-appearance: slider-vertical;
            /* Webkit */
            width: 8px;
            height: 200px;
            background: #30363d;
            accent-color: #238636;
        }

        button.reset-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f85149;
            border: none;
            cursor: pointer;
        }
    </style>
</head>

<body>

    <canvas id="bgCanvas"></canvas>

    <div class="controls-panel">
        <input type="range" id="jitterSlider" min="1" max="17" value="1" step="1">
        <button class="reset-btn" onclick="resetMask()" title="Reset"></button>
    </div>

    <script>
        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');

        const config = {
            pixelSize: 20,
            jitterAmount: 2,
            jitterSpeed: 0.01, // Default Ultra Slow (will be mapped from slider)
            revealRadius: 80,
            cleanImgSrc: '../assets/header.png',
            chaosImgSrc: '../assets/pixels.png' // New Green Seed
        };

        // State
        let w, h;
        let particles = [];
        let mouse = { x: -1000, y: -1000 };

        // --- ASSETS ---
        const cleanImg = new Image();
        const chaosImg = new Image();
        let loadedCount = 0;

        const checkLoad = () => {
            loadedCount++;
            if (loadedCount >= 2) {
                console.log('All assets loaded');
                resize();
            }
        };

        cleanImg.src = config.cleanImgSrc;
        cleanImg.onload = checkLoad;
        cleanImg.onerror = () => console.log('Clean img missing');

        chaosImg.src = config.chaosImgSrc;
        chaosImg.onload = checkLoad;
        chaosImg.onerror = () => console.log('Chaos img missing');

        // --- BUFFERS ---
        const maskCanvas = document.createElement('canvas'); // The eraser trail
        const maskCtx = maskCanvas.getContext('2d');

        const cleanCanvas = document.createElement('canvas'); // Bottom Layer
        const cleanCtx = cleanCanvas.getContext('2d');

        const chaosMapCanvas = document.createElement('canvas'); // Source for chaos colors
        const chaosMapCtx = chaosMapCanvas.getContext('2d');

        const chaosCanvas = document.createElement('canvas'); // Top Layer Frame
        const chaosCtx = chaosCanvas.getContext('2d');

        // --- INIT ---
        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;

            [maskCanvas, cleanCanvas, chaosMapCanvas, chaosCanvas].forEach(c => { c.width = w; c.height = h; });

            maskCtx.clearRect(0, 0, w, h); // Empty mask

            if (loadedCount >= 1) {
                // Draw Clean Layer (Bottom)
                drawCover(cleanCtx, cleanImg);
            }

            if (loadedCount >= 2) {
                // Draw Chaos Source Map (used for sampling colors)
                drawCover(chaosMapCtx, chaosImg);
            }

            initParticles();
        }

        function drawCover(targetCtx, img) {
            const ratio = Math.max(w / img.width, h / img.height);
            const nw = img.width * ratio;
            const nh = img.height * ratio;
            const ix = (w - nw) / 2;
            const iy = (h - nh) / 2;
            targetCtx.drawImage(img, ix, iy, nw, nh);
        }

        function initParticles() {
            const cols = Math.ceil(w / config.pixelSize);
            const rows = Math.ceil(h / config.pixelSize);
            particles = [];

            // Sample colors from Chaos Map
            // If chaosMap is empty (image failed), we fallback to cleanMap or green.

            let buffer = null;
            if (loadedCount >= 2) {
                buffer = chaosMapCtx.getImageData(0, 0, w, h).data;
            }

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const px = x * config.pixelSize;
                    const py = y * config.pixelSize;

                    let color = '#0e4429'; // Base Github Green

                    if (buffer) {
                        const cx = Math.floor(px + config.pixelSize / 2);
                        const cy = Math.floor(py + config.pixelSize / 2);
                        const i = (cy * w + cx) * 4;
                        color = `rgb(${buffer[i]}, ${buffer[i + 1]}, ${buffer[i + 2]})`;
                    }

                    particles.push({
                        x: px, y: py,
                        ox: px, oy: py,
                        color: color,
                        dx: 0, dy: 0
                    });
                }
            }
        }

        // --- INTERACTION ---
        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            const g = maskCtx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, config.revealRadius);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(1, 'rgba(255,255,255,0)');

            maskCtx.globalCompositeOperation = 'source-over';
            maskCtx.fillStyle = g;
            maskCtx.beginPath();
            maskCtx.arc(mouse.x, mouse.y, config.revealRadius, 0, Math.PI * 2);
            maskCtx.fill();
        });

        // Slider Logic
        const slider = document.getElementById('jitterSlider');
        slider.addEventListener('input', (e) => {
            // Map 1-17 to 0.01 - 0.17
            config.jitterSpeed = parseInt(e.target.value) / 100;
        });

        // --- RENDER LOOP ---
        function frame() {

            // 1. Draw Clean Bottom
            ctx.globalCompositeOperation = 'source-over';
            if (loadedCount >= 1) ctx.drawImage(cleanCanvas, 0, 0);
            else { ctx.fillStyle = '#0d1117'; ctx.fillRect(0, 0, w, h); }

            // 2. Prepare Chaos Top
            chaosCtx.clearRect(0, 0, w, h);

            particles.forEach(p => {
                if (Math.random() < config.jitterSpeed) {
                    p.dx = (Math.random() - 0.5) * config.jitterAmount;
                    p.dy = (Math.random() - 0.5) * config.jitterAmount;
                }
                chaosCtx.fillStyle = p.color;
                chaosCtx.fillRect(p.ox + p.dx, p.oy + p.dy, config.pixelSize + 0.5, config.pixelSize + 0.5);
            });

            // 3. Mask Chaos
            chaosCtx.globalCompositeOperation = 'destination-out';
            chaosCtx.drawImage(maskCanvas, 0, 0);
            chaosCtx.globalCompositeOperation = 'source-over';

            // 4. Combine
            ctx.drawImage(chaosCanvas, 0, 0);

            requestAnimationFrame(frame);
        }

        function resetMask() { maskCtx.clearRect(0, 0, w, h); }

        // Init
        // (Wait for images or timeout)
        setTimeout(() => { if (loadedCount < 2) resize(); }, 1000);

    </script>
</body>

</html>