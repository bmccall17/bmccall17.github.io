<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test Bench: Polished Leak (Final V6)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0d1117;
            color: #c9d1d9;
            font-family: monospace;
            overflow: hidden;
        }

        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* Minimalist Left Controls */
        .controls-panel {
            position: fixed;
            top: 50%;
            left: 0;
            /* Flush left */
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 100;
            width: 7px;
            /* Specified width */
        }

        input[type=range] {
            writing-mode: bt-lr;
            /* IE/Edge */
            -webkit-appearance: slider-vertical;
            /* Webkit */
            width: 7px;
            /* Specified width */
            height: 300px;
            background: #21262d;
            accent-color: #238636;
            cursor: ns-resize;
            margin: 0;
            padding: 0;
            border-radius: 4px;
        }

        button.reset-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f85149;
            border: none;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        button.reset-btn:hover {
            opacity: 1;
        }

        /* Diagnostic Panel */
        #diagnostics {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #30363d;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            display: block;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            border-bottom: 1px solid #30363d;
            padding-bottom: 2px;
        }

        .status-ok {
            color: #238636;
        }

        .status-err {
            color: #f85149;
        }

        .log-box {
            height: 100px;
            overflow-y: auto;
            background: #000;
            border: 1px solid #30363d;
            padding: 5px;
            margin-top: 10px;
            color: #8b949e;
        }
    </style>
</head>

<body>

    <canvas id="bgCanvas"></canvas>

    <div class="controls-panel">
        <input type="range" id="jitterSlider" min="17" max="170" value="17" step="1" title="Jitter Speed">
        <button class="reset-btn" onclick="resetMask()" title="Reset"></button>
    </div>

    <!-- Diagnostic Overlay -->
    <div id="diagnostics">
        <h3>System Diagnostics</h3>
        <div class="status-row"><span>Canvas:</span> <span id="status-canvas">Waiting...</span></div>
        <div class="status-row"><span>Clean Image:</span> <span id="status-clean">Loading...</span></div>
        <div class="status-row"><span>Chaos Image:</span> <span id="status-chaos">Loading...</span></div>
        <div class="status-row"><span>Particles:</span> <span id="status-parts">0</span></div>
        <div class="status-row"><span>Jitter:</span> <span id="status-jitter">0.017</span></div>
        <div class="log-box" id="logBox">Initializing...<br></div>
        <div style="margin-top:10px; text-align:right;">
            <button onclick="forceRestart()">Force Restart</button>
            <button onclick="toggleFallback()">Toggle Fallback</button>
        </div>
    </div>

    <script>
        function log(msg, type = 'info') {
            const box = document.getElementById('logBox');
            const line = document.createElement('div');
            line.style.color = type === 'error' ? '#f85149' : '#8b949e';
            line.textContent = `> ${msg}`;
            box.appendChild(line);
            box.scrollTop = box.scrollHeight;
        }

        function setStatus(id, text, type) {
            const el = document.getElementById(id);
            el.textContent = text;
            el.className = type === 'ok' ? 'status-ok' : (type === 'err' ? 'status-err' : '');
        }

        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');

        const config = {
            pixelSize: 20,
            jitterAmount: 2,
            jitterSpeed: 0.017, // New Default
            revealRadius: 80,
            cleanImgSrc: '../assets/header.png',
            chaosImgSrc: '../assets/pixels.png'
        };

        // State
        let w, h;
        let particles = [];
        let mouse = { x: -1000, y: -1000 };
        let useFallback = false;

        // --- ASSETS ---
        const cleanImg = new Image();
        const chaosImg = new Image();

        let loadedCount = 0;

        const checkLoad = (name) => {
            loadedCount++;
            log(`${name} Loaded. (${loadedCount}/2)`, 'ok');
            if (name === 'Clean') setStatus('status-clean', `${cleanImg.width}x${cleanImg.height}`, 'ok');
            if (name === 'Chaos') setStatus('status-chaos', `${chaosImg.width}x${chaosImg.height}`, 'ok');

            if (loadedCount >= 2) {
                log('Assets Ready.', 'ok');
                resize();
            }
        };

        const handleErr = (name, e) => {
            log(`Failed to load ${name}`, 'error');
            setStatus(`status-${name.toLowerCase()}`, 'FAILED', 'err');
        };

        cleanImg.onload = () => checkLoad('Clean');
        cleanImg.onerror = (e) => handleErr('Clean', e);
        cleanImg.src = config.cleanImgSrc;

        chaosImg.onload = () => checkLoad('Chaos');
        chaosImg.onerror = (e) => handleErr('Chaos', e);
        chaosImg.src = config.chaosImgSrc;

        // Buffers
        const maskCanvas = document.createElement('canvas'); // The eraser trail
        const maskCtx = maskCanvas.getContext('2d');
        const cleanCanvas = document.createElement('canvas'); // Bottom Layer
        const cleanCtx = cleanCanvas.getContext('2d');
        const chaosMapCanvas = document.createElement('canvas'); // Source for chaos colors
        const chaosMapCtx = chaosMapCanvas.getContext('2d');
        const chaosCanvas = document.createElement('canvas'); // Top Layer Frame
        const chaosCtx = chaosCanvas.getContext('2d');

        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            setStatus('status-canvas', `${w}x${h}`, 'ok');

            [maskCanvas, cleanCanvas, chaosMapCanvas, chaosCanvas].forEach(c => { c.width = w; c.height = h; });
            maskCtx.clearRect(0, 0, w, h);

            try {
                if (loadedCount >= 1 && !useFallback) {
                    drawCover(cleanCtx, cleanImg);
                } else {
                    cleanCtx.fillStyle = '#0d1117'; cleanCtx.fillRect(0, 0, w, h);
                    cleanCtx.fillStyle = '#fff'; cleanCtx.font = '30px monospace'; cleanCtx.fillText('CLEAN LAYER (FALLBACK)', 50, h / 2);
                }

                if (loadedCount >= 2 && !useFallback) {
                    generateTiledChaos(chaosMapCtx, chaosImg);
                }

                initParticles();
            } catch (e) {
                log(`Resize Error: ${e.message}`, 'error');
            }
        }

        function drawCover(targetCtx, img) {
            if (!img.width) return;
            const ratio = Math.max(w / img.width, h / img.height);
            const nw = img.width * ratio;
            const nh = img.height * ratio;
            const ix = (w - nw) / 2;
            const iy = (h - nh) / 2;
            targetCtx.drawImage(img, ix, iy, nw, nh);
        }

        function generateTiledChaos(targetCtx, img) {
            // Tile and Randomize
            const tileW = img.width;
            const tileH = img.height;
            const cols = Math.ceil(w / tileW);
            const rows = Math.ceil(h / tileH);

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    targetCtx.save();
                    // Center of tile
                    const cx = c * tileW + tileW / 2;
                    const cy = r * tileH + tileH / 2;
                    targetCtx.translate(cx, cy);

                    // Rotations
                    const rot = Math.floor(Math.random() * 4) * (Math.PI / 2);
                    targetCtx.rotate(rot);

                    // Flips
                    const sx = Math.random() > 0.5 ? 1 : -1;
                    const sy = Math.random() > 0.5 ? 1 : -1;
                    targetCtx.scale(sx, sy);

                    targetCtx.drawImage(img, -tileW / 2, -tileH / 2);
                    targetCtx.restore();
                }
            }
            log('Generated Tiled Chaos Map.', 'ok');
        }

        function initParticles() {
            const cols = Math.ceil(w / config.pixelSize);
            const rows = Math.ceil(h / config.pixelSize);
            particles = [];

            // Sample colors from Chaos Map
            let buffer = null;
            try {
                if (loadedCount >= 2 && !useFallback) {
                    buffer = chaosMapCtx.getImageData(0, 0, w, h).data;
                }
            } catch (e) {
                log('Security/CORS Error reading pixels. Using fallback colors.', 'error');
            }

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const px = x * config.pixelSize;
                    const py = y * config.pixelSize;

                    let color = `hsl(${Math.random() * 360}, 50%, 20%)`;

                    if (buffer) {
                        const cx = Math.floor(px + config.pixelSize / 2);
                        const cy = Math.floor(py + config.pixelSize / 2);
                        const i = (cy * w + cx) * 4;
                        if (buffer[i] !== undefined) {
                            color = `rgb(${buffer[i]}, ${buffer[i + 1]}, ${buffer[i + 2]})`;
                        }
                    } else if (useFallback) {
                        color = `hsl(${(x + y) * 5}, 50%, 50%)`;
                    } else {
                        color = '#0e4429';
                    }

                    particles.push({
                        x: px, y: py,
                        ox: px, oy: py,
                        color: color,
                        dx: 0, dy: 0
                    });
                }
            }
            setStatus('status-parts', particles.length, 'ok');
        }

        // --- INTERACTION ---
        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            const g = maskCtx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, config.revealRadius);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(1, 'rgba(255,255,255,0)');

            maskCtx.globalCompositeOperation = 'source-over';
            maskCtx.fillStyle = g;
            maskCtx.beginPath();
            maskCtx.arc(mouse.x, mouse.y, config.revealRadius, 0, Math.PI * 2);
            maskCtx.fill();
        });

        const slider = document.getElementById('jitterSlider');
        slider.addEventListener('input', (e) => {
            // Range 17 - 170 => 0.017 - 0.170
            config.jitterSpeed = parseInt(e.target.value) / 1000;
            document.getElementById('status-jitter').textContent = config.jitterSpeed.toFixed(3);
        });

        function frame() {
            ctx.fillStyle = '#0d1117'; ctx.fillRect(0, 0, w, h);

            // 1. Draw Clean Bottom
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(cleanCanvas, 0, 0);

            // 2. Prepare Chaos Top
            chaosCtx.clearRect(0, 0, w, h);

            particles.forEach(p => {
                if (Math.random() < config.jitterSpeed) {
                    p.dx = (Math.random() - 0.5) * config.jitterAmount;
                    p.dy = (Math.random() - 0.5) * config.jitterAmount;
                }
                chaosCtx.fillStyle = p.color;
                chaosCtx.fillRect(p.ox + p.dx, p.oy + p.dy, config.pixelSize + 0.5, config.pixelSize + 0.5);
            });

            // 3. Mask Chaos
            chaosCtx.globalCompositeOperation = 'destination-out';
            chaosCtx.drawImage(maskCanvas, 0, 0);
            chaosCtx.globalCompositeOperation = 'source-over';

            // 4. Combine
            ctx.drawImage(chaosCanvas, 0, 0);

            requestAnimationFrame(frame);
        }

        function resetMask() { maskCtx.clearRect(0, 0, w, h); log('Trail Reset.'); }
        function forceRestart() { loadedCount = 2; resize(); }
        function toggleFallback() {
            useFallback = !useFallback;
            log(`Fallback Mode: ${useFallback}`);
            resize();
        }

        setTimeout(() => {
            if (loadedCount < 2) {
                log('Timeout waiting for images. Try "Toggle Fallback".', 'warn');
            }
        }, 3000);

        resize();
        frame();

    </script>
</body>

</html>