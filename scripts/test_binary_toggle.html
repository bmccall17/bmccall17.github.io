<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test Bench: Polished Leak (Complexity Protocol)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, sans-serif;
            overflow: hidden;
        }

        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
        }

        .overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem;
            border-radius: 8px;
        }
    </style>
</head>

<body>

    <canvas id="bgCanvas"></canvas>

    <div class="overlay">
        <h1>Leak Test V3 (Complexity Protocol)</h1>
        <p>1. Bottom Layer: Clean Image<br>
            2. Top Layer: Pixel Chaos<br>
            3. Mouse: <b>Erases</b> Top Layer (Reveals Clean)<br>
            Speed: Ultra Slow</p>
    </div>

    <div class="controls">
        <button onclick="resetMask()">Reset Trail</button>
        <button onclick="toggleImage()">Toggle Image</button>
    </div>

    <script>
        // --- COMPLEXITY PROTOCOL: DEFINITIONS ---
        // GOAL: Reveal clean image by "wiping away" the chaos pixels.
        // METHOD: Destination-Out masking on the Chaos Layer.

        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');

        const config = {
            pixelSize: 20,
            jitterAmount: 2,
            jitterSpeed: 0.02, // Ultra Slow
            revealRadius: 80,
            imageSrc: '../assets/header.png'
        };

        // State
        let w, h;
        let particles = [];
        let mouse = { x: -1000, y: -1000 };
        let useImage = true;
        let imageLoaded = false;

        // --- ASSETS ---
        const img = new Image();
        img.src = config.imageSrc;
        img.onload = () => { console.log('Assets loaded'); imageLoaded = true; resize(); };
        img.onerror = () => { console.log('Assets missing'); };

        // --- OFFSCREEN BUFFERS ---
        // 1. maskCanvas: Stores the "Trail" (Alpha=1 where erased)
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');

        // 2. cleanCanvas: Stores the resized Clean Image (Bottom Layer)
        const cleanCanvas = document.createElement('canvas');
        const cleanCtx = cleanCanvas.getContext('2d');

        // 3. chaosCanvas: Scratchpad for one frame of pixels (Top Layer)
        const chaosCanvas = document.createElement('canvas');
        const chaosCtx = chaosCanvas.getContext('2d');

        // --- INIT ---
        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;

            [maskCanvas, cleanCanvas, chaosCanvas].forEach(c => { c.width = w; c.height = h; });

            // Reset Mask (Black = No Erase)
            // Actually for 'destination-out', we draw content where we want to erase.
            // So we start empty.
            maskCtx.clearRect(0, 0, w, h);

            if (imageLoaded) {
                // Prepare Clean Layer
                const ratio = Math.max(w / img.width, h / img.height);
                const nw = img.width * ratio;
                const nh = img.height * ratio;
                const ix = (w - nw) / 2;
                const iy = (h - nh) / 2;
                cleanCtx.drawImage(img, ix, iy, nw, nh);
            }

            initParticles();
        }

        function initParticles() {
            const cols = Math.ceil(w / config.pixelSize);
            const rows = Math.ceil(h / config.pixelSize);
            particles = [];

            // Sample colors from Clean Layer
            const buffer = cleanCtx.getImageData(0, 0, w, h).data;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const px = x * config.pixelSize;
                    const py = y * config.pixelSize;

                    let color = `hsl(${Math.random() * 360}, 50%, 20%)`; // Dark fallback

                    if (useImage && imageLoaded) {
                        // Sample Center
                        const cx = Math.floor(px + config.pixelSize / 2);
                        const cy = Math.floor(py + config.pixelSize / 2);
                        const i = (cy * w + cx) * 4;
                        if (buffer[i] !== undefined) {
                            color = `rgb(${buffer[i]}, ${buffer[i + 1]}, ${buffer[i + 2]})`;
                        }
                    }

                    particles.push({
                        x: px, y: py,
                        ox: px, oy: py,
                        color: color,
                        dx: 0, dy: 0
                    });
                }
            }
        }

        // --- INTERACTION ---
        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            // Draw to Mask
            // We draw a "Soft Brush"
            const g = maskCtx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, config.revealRadius);
            g.addColorStop(0, 'rgba(255,255,255,1)'); // Solid erase center
            g.addColorStop(1, 'rgba(255,255,255,0)'); // Fade edge

            maskCtx.globalCompositeOperation = 'source-over';
            maskCtx.fillStyle = g;
            maskCtx.beginPath();
            maskCtx.arc(mouse.x, mouse.y, config.revealRadius, 0, Math.PI * 2);
            maskCtx.fill();
        });

        // --- RENDER LOOP ---
        function frame() {
            // 1. Draw Clean Bottom Layer
            // (Always draw this first)
            ctx.globalCompositeOperation = 'source-over';

            if (useImage && imageLoaded) {
                ctx.drawImage(cleanCanvas, 0, 0);
            } else {
                ctx.fillStyle = '#161b22'; // Dark fallback bg
                ctx.fillRect(0, 0, w, h);
            }

            // 2. Prepare Chaos Top Layer (on scratchpad)
            chaosCtx.clearRect(0, 0, w, h);

            particles.forEach(p => {
                // Jitter
                if (Math.random() < config.jitterSpeed) {
                    p.dx = (Math.random() - 0.5) * config.jitterAmount;
                    p.dy = (Math.random() - 0.5) * config.jitterAmount;
                }

                chaosCtx.fillStyle = p.color;
                // Draw slightly oversize to prevent cracks
                chaosCtx.fillRect(p.ox + p.dx, p.oy + p.dy, config.pixelSize + 0.5, config.pixelSize + 0.5);
            });

            // 3. Apply Mask to Chaos Layer
            // "Destination-Out" removes pixels from Chaos where Mask is opaque
            chaosCtx.globalCompositeOperation = 'destination-out';
            chaosCtx.drawImage(maskCanvas, 0, 0);
            chaosCtx.globalCompositeOperation = 'source-over'; // Reset

            // 4. Draw Chaos Layer onto Main Canvas
            ctx.drawImage(chaosCanvas, 0, 0);

            requestAnimationFrame(frame);
        }

        // --- UTILS ---
        function resetMask() { maskCtx.clearRect(0, 0, w, h); }
        function toggleImage() { useImage = !useImage; initParticles(); }

        // Start
        resize();
        frame();

    </script>
</body>

</html>