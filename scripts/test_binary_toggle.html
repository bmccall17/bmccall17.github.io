<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test Bench: Polished Leak (Physx V7)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0d1117;
            color: #c9d1d9;
            font-family: monospace;
            overflow: hidden;
        }

        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* UI Container */
        .controls-panel {
            position: fixed;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 100;
            width: 20px;
            /* Slight width for hover hit area */
        }

        /* Custom Slider Styling */
        input[type=range] {
            writing-mode: bt-lr;
            /* IE */
            -webkit-appearance: slider-vertical;
            /* Webkit */
            width: 8px;
            height: 300px;
            background: transparent;
            /* No background track visible */
            cursor: ns-resize;
            margin: 0;
        }

        /* Attempting to style the run/track if possible, but webkit-slider-vertical is tricky. 
           We'll rely on the default track being minimal or invisible. */

        /* Reset Button */
        button.reset-btn {
            width: 12px;
            height: 12px;
            background: #f85149;
            border: none;
            /* Straight corners */
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button.reset-btn:hover {
            transform: scale(1.5);
            /* Magnify */
        }

        /* Diagnostic Panel */
        #diagnostics {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #30363d;
            padding: 10px;
            border-radius: 4px;
            font-size: 11px;
            z-index: 1000;
            pointer-events: none;
            /* Click through */
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .status-ok {
            color: #238636;
        }
    </style>
</head>

<body>

    <canvas id="bgCanvas"></canvas>

    <div class="controls-panel">
        <!-- Range: 17 to 1700 (0.0017 to 0.17) -->
        <input type="range" id="jitterSlider" min="17" max="1700" value="17" step="1" title="Entropy">
        <button class="reset-btn" onclick="initParticles()" title="Reset Entropy"></button>
    </div>

    <!-- Minimal Diagnostics -->
    <div id="diagnostics">
        <div class="status-row"><span>Particles:</span> <span id="s-count">0</span></div>
        <div class="status-row"><span>Entropy:</span> <span id="s-jitter">0.0017</span></div>
        <div class="status-row"><span id="s-log">Init...</span></div>
    </div>

    <script>
        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');
        const diagnostics = {
            count: document.getElementById('s-count'),
            jitter: document.getElementById('s-jitter'),
            log: document.getElementById('s-log')
        };

        const config = {
            pixelSize: 20,
            jitterSpeed: 0.0017, // Low end
            jitterAmount: 2,
            suckRadius: 100,     // Black Hole Horizon
            suckSpeed: 0.15,      // How fast they fly in
            cleanImgSrc: '../assets/header.png',
            chaosImgSrc: '../assets/pixels.png'
        };

        // State
        let w, h;
        let particles = [];
        let mouse = { x: -5000, y: -5000 };

        // Assets
        const cleanImg = new Image();
        const chaosImg = new Image();
        let assetsReady = false;
        let loadCount = 0;

        const checkLoad = () => { loadCount++; if (loadCount >= 2) { assetsReady = true; resize(); } };
        cleanImg.onload = checkLoad; cleanImg.src = config.cleanImgSrc;
        chaosImg.onload = checkLoad; chaosImg.src = config.chaosImgSrc;

        // Force resize handling
        window.addEventListener('resize', resize);

        // Input Handling (Mouse & Touch)
        const updateInput = (x, y, type) => {
            mouse.x = x;
            mouse.y = y;
            // Optional: Log input type once to verify
            if (diagnostics.log.textContent !== type) {
                diagnostics.log.textContent = `Input: ${type}`;
            }
        };

        window.addEventListener('mousemove', e => {
            updateInput(e.clientX, e.clientY, 'Mouse');
        });

        // Touch Support
        window.addEventListener('touchmove', e => {
            e.preventDefault(); // Stop scrolling while dragging
            const t = e.touches[0];
            updateInput(t.clientX, t.clientY, 'Touch');
        }, { passive: false });

        window.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.touches[0];
            updateInput(t.clientX, t.clientY, 'Touch');
        }, { passive: false });

        // Toggle Clean Canvas (Cached)
        const cleanCanvas = document.createElement('canvas');
        const cleanCtx = cleanCanvas.getContext('2d');
        const chaosMapCanvas = document.createElement('canvas');
        const chaosMapCtx = chaosMapCanvas.getContext('2d');

        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            cleanCanvas.width = w; cleanCanvas.height = h;
            chaosMapCanvas.width = w; chaosMapCanvas.height = h;

            if (assetsReady) {
                drawCover(cleanCtx, cleanImg);
                generateTiledChaos(chaosMapCtx, chaosImg);
            }
            initParticles();
        }

        function drawCover(ctx, img) {
            const ratio = Math.max(w / img.width, h / img.height);
            const nw = img.width * ratio;
            const nh = img.height * ratio;
            const ix = (w - nw) / 2;
            const iy = (h - nh) / 2;
            ctx.drawImage(img, ix, iy, nw, nh);
        }

        function generateTiledChaos(ctx, img) {
            const tw = img.width; const th = img.height;
            const cols = Math.ceil(w / tw); const rows = Math.ceil(h / th);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    ctx.save();
                    ctx.translate(x * tw + tw / 2, y * th + th / 2);
                    ctx.rotate(Math.floor(Math.random() * 4) * Math.PI / 2);
                    ctx.scale(Math.random() > .5 ? 1 : -1, Math.random() > .5 ? 1 : -1);
                    ctx.drawImage(img, -tw / 2, -th / 2);
                    ctx.restore();
                }
            }
        }

        function initParticles() {
            particles = [];
            const pc = Math.ceil(w / config.pixelSize);
            const pr = Math.ceil(h / config.pixelSize);

            // Sample colors
            let data = null;
            if (assetsReady) data = chaosMapCtx.getImageData(0, 0, w, h).data;

            for (let y = 0; y < pr; y++) {
                for (let x = 0; x < pc; x++) {
                    const px = x * config.pixelSize;
                    const py = y * config.pixelSize;
                    let color = '#0e4429';

                    if (data) {
                        const cx = Math.floor(px + config.pixelSize / 2);
                        const cy = Math.floor(py + config.pixelSize / 2);
                        const i = (cy * w + cx) * 4;
                        color = `rgb(${data[i]},${data[i + 1]},${data[i + 2]})`;
                    }

                    particles.push({
                        x: px, y: py,
                        ox: px, oy: py, // Original Grid Pos (Jitter anchor)
                        color: color,
                        dx: 0, dy: 0,   // Jitter offset
                        state: 0,       // 0=IDLE, 1=SUCKED, 2=DEAD
                        size: config.pixelSize
                    });
                }
            }
            diagnostics.log.textContent = "Particles Reset";
        }

        // --- PHYSICS LOOP ---
        function frame() {
            // Background: Clean Layer
            ctx.globalCompositeOperation = 'source-over';
            if (assetsReady) ctx.drawImage(cleanCanvas, 0, 0);
            else { ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h); }

            let activeCount = 0;

            // Update & Draw Particles
            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];

                if (p.state === 2) continue; // Skip Dead
                activeCount++;

                // --- LOGIC ---
                if (p.state === 0) { // IDLE
                    // Jitter
                    if (Math.random() < config.jitterSpeed) {
                        p.dx = (Math.random() - 0.5) * config.jitterAmount;
                        p.dy = (Math.random() - 0.5) * config.jitterAmount;
                    }

                    // Check Black Hole Distance
                    const dx = mouse.x - p.x;
                    const dy = mouse.y - p.y;
                    const distSq = dx * dx + dy * dy;

                    if (distSq < config.suckRadius * config.suckRadius) {
                        p.state = 1; // Event Horizon Crossed
                    }

                    // Draw Idle
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.ox + p.dx, p.oy + p.dy, config.pixelSize + 0.5, config.pixelSize + 0.5);

                } else if (p.state === 1) { // SUCKED
                    // Move towards mouse
                    const dx = mouse.x - p.x;
                    const dy = mouse.y - p.y;

                    p.x += dx * config.suckSpeed;
                    p.y += dy * config.suckSpeed;
                    p.size *= 0.85; // Shrink

                    // Draw Sucked
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);

                    // Kill condition
                    if (p.size < 1 || (Math.abs(dx) < 5 && Math.abs(dy) < 5)) {
                        p.state = 2; // Dead (Singularity reached)
                    }
                }
            }

            diagnostics.count.textContent = activeCount;
            requestAnimationFrame(frame);
        }

        // --- CONTROLS ---
        const slider = document.getElementById('jitterSlider');
        slider.addEventListener('input', e => {
            config.jitterSpeed = parseInt(e.target.value) / 10000;
            diagnostics.jitter.textContent = config.jitterSpeed.toFixed(4);
        });

        // Auto-fix for local testing delays
        setTimeout(() => { if (!assetsReady) resize(); }, 1500);

        resize();
        frame();

    </script>
</body>

</html>